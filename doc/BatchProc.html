<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Michelle Mellers" />


<title>batchProc</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">batchProc</h1>
<h4 class="author">Michelle Mellers</h4>



<div id="vignette-for-randbatch" class="section level2">
<h2>Vignette for randBatch</h2>
<p>This vignette illustrates the functionality of the R-package
“randBatch”. It demonstrates all of the functions within the package by
using an example use of the package. This document also illustrates an
example pipeline to describe the flow of a randomization using the
package.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(randBatch)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="co">#&gt; ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a><span class="co">#&gt; ✔ dplyr     1.1.4     ✔ readr     2.1.5</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a><span class="co">#&gt; ✔ forcats   1.0.0     ✔ stringr   1.5.1</span></span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a><span class="co">#&gt; ✔ ggplot2   3.5.2     ✔ tibble    3.2.1</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a><span class="co">#&gt; ✔ lubridate 1.9.4     ✔ tidyr     1.3.1</span></span>
<span id="cb1-8"><a href="#cb1-8" tabindex="-1"></a><span class="co">#&gt; ✔ purrr     1.0.4     </span></span>
<span id="cb1-9"><a href="#cb1-9" tabindex="-1"></a><span class="co">#&gt; ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──</span></span>
<span id="cb1-10"><a href="#cb1-10" tabindex="-1"></a><span class="co">#&gt; ✖ dplyr::filter() masks stats::filter()</span></span>
<span id="cb1-11"><a href="#cb1-11" tabindex="-1"></a><span class="co">#&gt; ✖ dplyr::lag()    masks stats::lag()</span></span>
<span id="cb1-12"><a href="#cb1-12" tabindex="-1"></a><span class="co">#&gt; ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</span></span></code></pre></div>
</div>
<div id="example-use-case." class="section level1">
<h1>Example Use Case.</h1>
<p>We start by demonstrating an example randomization problem for a 2:1
matched case-control study. The analyst would like to generate labels
for a fully randomized samples for serum samples in batches and specify
a certain number of QC samples to test the batch sizes. Extra blood from
the samples will be used for a secondary test. This apparatus has
different sized batches then the original batch so we must reassign the
batches for the new apparatus. To make it easier on the scientists in
the lab, the number of “switches” to the new configuration must be
minimized.</p>
<div id="step-1-generate-a-test-dataset" class="section level3">
<h3>Step 1: Generate a test dataset</h3>
<p>We must first generate a test dataset. The package includes the
function “testRand” that allows specification of size, matching, plate
size, and the child per mother specification.</p>
<p>Variable descriptions of testRand include: rowSize: size of plate row
colSize: size of plat column studySize: size of each arm for the study
expNS: expected number of samples for all study arms numCC: expected
number of controls for each case QCpt: percent of QC samples for the
total study size child: number of children per mother aliquots</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>testR <span class="ot">&lt;-</span> <span class="fu">testRand</span>(<span class="at">rowSize=</span><span class="dv">20</span>,<span class="at">colSize=</span><span class="dv">15</span>,<span class="at">studySize=</span><span class="dv">1000</span>,<span class="at">expNS=</span><span class="dv">7000</span>,<span class="at">numCC=</span><span class="dv">2</span>,<span class="at">QCpct=</span><span class="fl">0.05</span>,<span class="at">child=</span><span class="dv">4</span>)</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>serumIDs <span class="ot">&lt;-</span> testR[[<span class="dv">1</span>]]</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>serumLoc <span class="ot">&lt;-</span> testR[[<span class="dv">2</span>]]</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>emptyQC <span class="ot">&lt;-</span> testR[[<span class="dv">3</span>]]</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>motherQC <span class="ot">&lt;-</span> testR[[<span class="dv">4</span>]]</span></code></pre></div>
<p>We create a test dataset with a plate: 20 rows (rowSize) 15 columns
(colSize) 1000 individuals per arm (studySize) 7000 expected number of
samples (samples) 2 cases per control (numCC) 5% percentage of QC
samples (QCpct) 4 children per mother (child)</p>
<p>We divide the output of this function into 4 different test datasets.
1. serumIDs: serum ID with participant ID 2. serumLoc: serum Packing
location 3. emptyQC: empty QC vials 4. motherQC: qc “mother” samples</p>
<p>We next test the serumIDs and individual IDs to ensure that unique
IDs are assigned to each serum sample. In this example, the ID is unique
if the output dataset has no rows.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>tests1 <span class="ot">&lt;-</span> <span class="fu">uniqueID</span>(serumIDs,<span class="st">&quot;serumID&quot;</span>)</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>tests2 <span class="ot">&lt;-</span> <span class="fu">uniqueID</span>(serumLoc,<span class="st">&quot;serumID&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>tests3 <span class="ot">&lt;-</span> <span class="fu">uniqueID</span>(emptyQC,<span class="st">&quot;serumID&quot;</span>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>tests4 <span class="ot">&lt;-</span> <span class="fu">uniqueID</span>(motherQC,<span class="st">&quot;serumID&quot;</span>)</span></code></pre></div>
</div>
<div id="step-2-format-datasets" class="section level3">
<h3>Step 2: Format Datasets</h3>
<p>In this step we next format the datasets for entry into the
Randomization function.</p>
<p>We first assign IDs linking mother/child and events using the
function “randTest”. The output of the function is a dataset with the ID
links. This function requires: dataMom: The mother dataset. dataChild:
Child dataset. maxAliq: number of aliquots per mother aliquot. nEvent:
number of aliquots per each of event or lab.</p>
<p>The function “formatRand” formats the dataset for the randomization
function. This function inputs serum data for both the study subjects
and QC. QCData: QC data serumIDR: serum data with serumIDs serumPack:
serum data with packing lists</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>QCMaster <span class="ot">&lt;-</span> <span class="fu">randTest</span>(<span class="at">dataMom=</span>motherQC,<span class="at">dataChild=</span>emptyQC,<span class="at">maxAliq=</span><span class="dv">4</span>, <span class="at">nEvent=</span><span class="fu">c</span>(<span class="dv">28</span>,<span class="dv">27</span>,<span class="dv">28</span>,<span class="dv">30</span>))</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>serumMaster <span class="ot">&lt;-</span> <span class="fu">formatRand</span>(<span class="at">QCdata=</span>QCMaster,<span class="at">serumIDR=</span>serumIDs,<span class="at">serumPack=</span>serumLoc)</span></code></pre></div>
<p>The dataset “serumMaster” is a dataset that is formatted and ready
for the randomization file.</p>
</div>
<div id="step-3-randomize-dataset" class="section level3">
<h3>Step 3: Randomize Dataset</h3>
<p>While the practice dataset includes multiple events or labs that can
process the samples, we are only going to randomize a single event at a
time. We subset the dataset, serumMaster to only include a single event.
In this example we will pick event 3. The function, allRand, randomizes
aliquots to batches. dataR: data for randomization batchTot:
c(batchTot1, batchTot2) sizes of plates, just use one plate per batch,
batch size inclusive of QC samples numQC: number of QC samples per batch
withinN: number of samples away that the QC samples must be from each
other numMatch: number of QC samples from a single mother within a batch
chkRep: check if there is a repeat of the groups within the batches</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>serumMaster3 <span class="ot">&lt;-</span> serumMaster <span class="sc">%&gt;%</span> <span class="fu">filter</span>(event <span class="sc">==</span> <span class="dv">3</span>)</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>serumRand <span class="ot">&lt;-</span> <span class="fu">allRand</span>(<span class="at">dataR=</span>serumMaster3,<span class="at">batchTot=</span><span class="fu">c</span>(<span class="dv">40</span>,<span class="dv">44</span>), <span class="at">numQC=</span><span class="dv">2</span>,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>                     <span class="at">withinN=</span><span class="dv">2</span>,<span class="at">numMatch=</span><span class="dv">2</span>,<span class="at">chkRep=</span><span class="dv">1</span>)</span></code></pre></div>
<p>The example code demonstrates the use of the randomization function.
The output, “serumRand” is the randomized serum samples.</p>
</div>
<div id="step-4-check-the-randomization" class="section level3">
<h3>Step 4: check the randomization</h3>
<p>We can verify the success of the randomization using seven different
tests. We describe these verification tests and the functions that
implement these tests.</p>
<p><strong>Test 1:</strong> no case-control samples across batches or
plates.</p>
<p>This function “testCCAcross” inputs the randomized dataset.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">testCCAcross</span>(<span class="at">dataS=</span>serumRand)</span></code></pre></div>
<p>The output dataset, test, shows all of the case-control groups that
are split across batches. In this example the output should have 0
rows.</p>
<p><strong>Test 2:</strong> measures that every batch has at least the
specified number of matching QC sample sets in a batch.</p>
<p>The function “testQCmatch” inputs: dataS: randomized data numQCs:
number of QCs specified per dataset numMatch: number of QC samples form
a single mother within a batch</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">testQCmatch</span>(<span class="at">dataS=</span>serumRand,<span class="at">numQCs=</span><span class="dv">4</span>,<span class="at">numMatch=</span><span class="dv">2</span>)</span></code></pre></div>
<p>The output lists all batches with not enough QC sample sets or the QC
samples do not come from the same mother.</p>
<p><strong>Test 3:</strong> tests for unique serum samples in the
randomized datset. The function, uniqueID, is repeated from above.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">uniqueID</span>(serumRand,<span class="st">&quot;serumID&quot;</span>)</span></code></pre></div>
<p>The output lists any duplicates of IDs in the dataset.</p>
<p><strong>Test 4:</strong> tests if sets are next to each other. Any
sets that are not next to each other are flagged.</p>
<p>The function, testPair, inputs “serumRand”.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">testPair</span>(<span class="at">dataS=</span>serumRand)</span></code></pre></div>
<p>The output reports any sets that are separated in the “loc”.</p>
<p><strong>Test 5:</strong> tests if a large number of cases or controls
are next to each other</p>
<p>The function, orderCases, has the inputs: dataI: test dataset betW:
number of cases or controls to check if they are next to each other</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">orderCases</span>(<span class="at">dataI=</span>serumRand,<span class="at">betW=</span><span class="dv">4</span>)</span></code></pre></div>
<p>The output stores if there are any cases or controls together beyond
a certain specified value. In this example the value is chosen to be 4.
The output lists the studyID of the groups that have many next to each
other.</p>
<p><strong>Test 6:</strong> counts the number of samples that are in
each of the batches. The function, batchCount, has the inputs: dataS:
test dataset batchSizeT: batch size to test for</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">batchCount</span>(<span class="at">dataS=</span>serumRand,<span class="at">batchSizeT=</span><span class="dv">84</span>)</span></code></pre></div>
<p>The output should be empty, as it contains the ID of any batch that
does not contain the specified number of samples. The last batch is not
reported if it has less than the specified number of samples.</p>
<p><strong>Test 7:</strong> count how many QC samples are in each of the
batches, and if it doesn’t match the number specified. The function,
countQC, contains: dataS: test dataset QCN: number of QC samples per
batch</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>test <span class="ot">&lt;-</span> <span class="fu">countQC</span>(<span class="at">dataS=</span>serumRand,<span class="at">QCN=</span><span class="dv">4</span>)</span></code></pre></div>
<p>The output includes any batches that does not contain the number of
QC samples specified. In this example there are 4.</p>
<p>Now that our randomized example dataset, serumRand, has passed all of
the verification checks, we can create our output packing lists.</p>
</div>
<div id="step-5-packing-lists-from-the-randomization-results" class="section level3">
<h3>Step 5: Packing Lists From the Randomization Results</h3>
<p>In or example we demonstration we demonstrate by outputting two
packing lists, one blinded and the other not blinded. We first
demonstrate the unblinded packing list with the original packing
location and title the dataset, unBlind.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>unBlind <span class="ot">&lt;-</span> <span class="fu">outputLab</span>(<span class="at">dataOut=</span>serumRand,<span class="at">blind=</span><span class="dv">0</span>,<span class="at">origP=</span><span class="dv">1</span>,<span class="at">maxRows=</span><span class="dv">9</span>,<span class="at">maxCols=</span><span class="dv">9</span>,<span class="at">newPack=</span><span class="dv">1</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>blind <span class="ot">&lt;-</span> <span class="fu">outputLab</span>(<span class="at">dataOut=</span>serumRand,<span class="at">blind=</span><span class="dv">1</span>,<span class="at">origP=</span><span class="dv">0</span>,<span class="at">maxRows=</span><span class="dv">9</span>,<span class="at">maxCols=</span><span class="dv">9</span>,<span class="at">newPack=</span><span class="dv">1</span>)</span></code></pre></div>
<p>The function, outputLab, has the following options: dataOut = dataset
to be formatted for packing list Blind = 0/1 indicator to select if a
blinded (1) or unblinded(0) packing list is to be generated origP = 0/1
indicator for inclusion of the original packing location (1) or deletion
of the packing location (0) maxRows = maximum row for the output dataset
maxCols = maximum column for the output dataset newPack = 0/1 indicator
to generate new packing locations</p>
<p>The second packing list, blind, demonstrates an output where the
packing list is blinded. The original packing location is also not
displayed. These packing lists can be printed for use.</p>
</div>
<div id="step-6-we-do-not-want-to-completely-re-randomize-but-we-may-need-to-change-parameters-such-as-plate-sizes-or-qc-samples-per-plate." class="section level3">
<h3>Step 6: We do not want to completely re-randomize, but we may need
to change parameters such as plate sizes or QC samples per plate.</h3>
<p>The analyst now wants to produce a new location list for serum
samples, but the test bench has different sized batches. dataIn:
randomized dataset numqc: number of QC samples per set numqcM: number of
qc matching samples batchS: new batch size</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>serumSwitch <span class="ot">&lt;-</span> <span class="fu">switchR</span>(<span class="at">dataIn=</span>serumRand,<span class="at">numqc=</span><span class="dv">2</span>,<span class="at">numqcM=</span><span class="dv">2</span>,<span class="at">batchS=</span><span class="dv">43</span>)</span></code></pre></div>
<p>In this example the batch size is now 43 samples with 2 QC samples
and 2 matching per batches.</p>
</div>
<div id="step-7-check-the-new-randomization-from-the-switching" class="section level3">
<h3>Step 7: check the new randomization from the switching</h3>
<p>As above we check the randomization for the serum switch.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>test1 <span class="ot">&lt;-</span> <span class="fu">testCCAcross</span>(serumSwitch)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>test2 <span class="ot">&lt;-</span> <span class="fu">testQCmatch</span>(serumSwitch,<span class="dv">2</span>,<span class="dv">2</span>)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>test3 <span class="ot">&lt;-</span> <span class="fu">uniqueID</span>(serumSwitch,<span class="st">&quot;serumID&quot;</span>)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>test4 <span class="ot">&lt;-</span> <span class="fu">testPair</span>(serumSwitch)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>test5 <span class="ot">&lt;-</span> <span class="fu">orderCases</span>(serumSwitch,<span class="dv">4</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>test6 <span class="ot">&lt;-</span> <span class="fu">batchCount</span>(serumSwitch,<span class="dv">43</span>)</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>test7 <span class="ot">&lt;-</span> <span class="fu">countQC</span>(serumSwitch,<span class="dv">2</span>)</span></code></pre></div>
<p>As a reminder, the functions of the tests are repeated below.
<strong>Test 1:</strong> no case-control samples across batches or
plates. <strong>Test 2</strong> The output shows the batches with QC
errors. The results are test 2 are fine, it just shows that there are
extra QC samples in a certain batch. <strong>Test 3</strong> The output
shows samples where the serum ID is repeated. <strong>Test 4</strong>
The “test” dataset contains any case-control sets that are not together.
<strong>Test 5</strong> The test data shows cases or controls that are
together. <strong>Test 6</strong> The test data contains batches with
more than the specified count (43) <strong>Test 7</strong> The output
contains batches that do not contain 2 QC samples.</p>
<p>Once this test is complete, we can output the packing lists for these
serum samples. These packing lists are outputted in the datasets not
Blinded (unBlindSw) and Blinded (blindSw).</p>
</div>
<div id="step-8-output-the-packing-lists-for-the-switchr-function" class="section level3">
<h3>Step 8: output the packing lists for the switchR function</h3>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>serumSwitchP <span class="ot">&lt;-</span> unBlind <span class="sc">%&gt;%</span> </span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>                <span class="fu">select</span>(serumID,rack,row,col) <span class="sc">%&gt;%</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>                <span class="fu">merge</span>(.,serumSwitch,<span class="at">by=</span><span class="st">&#39;serumID&#39;</span>)</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>unBlindSw <span class="ot">&lt;-</span> <span class="fu">outputLab</span>(serumSwitchP,<span class="at">blind=</span><span class="dv">0</span>,<span class="at">origP=</span>.,<span class="at">maxRows=</span>.,<span class="at">maxCols=</span>.,<span class="at">newPack=</span><span class="dv">0</span>)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>blindSw <span class="ot">&lt;-</span> <span class="fu">outputLab</span>(serumSwitchP,<span class="at">blind=</span><span class="dv">1</span>,<span class="at">origP=</span>.,<span class="at">maxRows=</span>.,<span class="at">maxCols=</span>.,<span class="at">newPack=</span><span class="dv">0</span>)</span></code></pre></div>
<p>All of the example functions have been shown, and a demonstration of
the pipeline for the package. The input datasets are formatted then
randomized using two different methods. These output datasets are
checked then packing lists are generated.</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
